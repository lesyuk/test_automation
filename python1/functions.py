# если много кода придется делать одинакового то используем функции, чтобы не копипастить

# выносим часть логики в одном место, где каждый раз все будет идти по одному и тому же сценарию при вызове

def add(x, y): # x, y - аргументы
    sm = x + y
    print(sm)
    return sm # помимо того что функции могут что-то делать и оперировать аргументами, они могут возращать результат


add(1, 3) # скобки - операция вызова той или иной функции
add(2, 3)
add(4, 4)

# теперь результат нашей функции мы можем присвоить в переменную
res1 = add(1, 2)
res2 = add(2, 3)
res3 = add(4, 4)
print(res1, res2, res3) # 3 5 8

print(type(add)) # <class 'function'>


# пример зачем использовать raise в исключениях
class MyException(Exception):
    pass
def division(x, y):
    try:
        print(x / y)
    except ZeroDivisionError:
        raise MyException() # выбрасываем наше исключение, чтобы потом с ним как-то взаимодействовать

try:
    division(2, 0)
except MyException:
    print('all ok')



