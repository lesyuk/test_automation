empty_list = []
empty_list1 = list()

# добаление элемента, всегда добавляется в конец
empty_list.append('123')
print(empty_list) # ['123']
empty_list.append('456')
print(empty_list) # ['123', '456']

# расширить список другим списком
empty_list.extend(['666', '777', '888']) # ['123', '456', '666', '777', '888']
print(empty_list) #

# подсчет длины списка
print(len(empty_list)) # 5

# обращение к индексам списка
print(empty_list[0])
print(empty_list[1])
print(empty_list[-1]) # с конца

# списки можно умножать. здесь исходный список не меняется, умножение за пределами объекта, мы вызываем его сверху
# изменяемые объекты меняются когда мы вызываем какие-то методы
print(empty_list * 2) # ['123', '456', '666', '777', '888', '123', '456', '666', '777', '888']
print(empty_list) # ['123', '456', '666', '777', '888']

# диапазоны списка (слайсинг, слайсы)
print(empty_list[1:3]) # важный момент: 2 - включитель, 5 - не включительно // ['456', '666']
print(empty_list[3:-1]) # ['777']
# в интервалах можно выходить за границы, он просто покажет все входящее в этот диапазон
print(empty_list[3:-1000]) # 1000 индекса в массиве нет // ['777', '888']
# помимо того, что можно задать нижнюю и верхнюю границы, через еще одно : можем задать шаг, который может быть любым
print(empty_list[0:5:2]) # ['123', '666', '888']
# можно убрать верхнюю и/или нижнюю границы, это будет означать, что мы хотим начинать с самого начала / до самого конца
print(empty_list[::2]) # ['123', '666', '888']
# можно задать отрицательный шаг
print(empty_list[::-1]) # берем весь диапазон и разворачиваем в обратном порядке // ['888', '777', '666', '456', '123']
print(empty_list[3:0:-1]) # с 3 по 0 в обратном порядке

# так как питон язык с динамической типизацией мы не указываем из каких элементов состоит список
new = ['123456', 123, 3.1, '', None]
print(new) # ['123', 123, 3.1, '', None]
# более того, элементом списка может быть еще один список
new.append(['111', 222, 444.44]) # ['123456', 123, 3.1, '', None, ['111', 222, 444.44]]
print(new)
# удаление (вытягивание) элемента из списка по индексу
print(new.pop(0)) # 123456
print(new) # [456, 3.1, '', None, ['111', 222, 444.44]]

# сортировка списков
# new.sort() сортируем список меняя элементы местами в данном случае в алфавитном порядке
# print(new) TypeError: '<' not supported between instances of 'str' and 'float'
# дело в том что список состоит из разных типов и к сожалению строгая типизация не пытается приводить типы друг к другу
# когда мы хотим сравнить строчку с числом (нужно для сортировки) то питон говорит что мы не можем этго сделать
# пока просто уберем строчку, оставим только числа
new = [12, 123, 3.1]
new.sort()
print(new) # [3.1, 12, 123] // в порядке возрастания
new.sort(reverse=True)
print(new) # [123, 12, 3.1] // в порядке убывания
# метод sort() новый список не создает, а сортирует исходные
# если мы хотим вместе с сортировкой создать новый список, то у нас есть встроенная команда sorted() куда мы можем передать список и его распечатать
print(sorted(new)) # [3.1, 12, 123] создастся новый объект, оригинальный никак не пострадает
print(new) # [123, 12, 3.1]
# как правило если мы вызываем метод поверх methodname(var) то будет создаваться новый объект
# когда мы вызываем метод у конкретного объекта скрее всего он будет изменен
print(bool([])) # False
print(bool([0])) # True

# разворот списка
new.reverse() # с изменением старого объекта
print(new) # [3.1, 12, 123]
reversed_string = reversed(new) # с созданием нового объекта # [123, 12, 3.1]
print(list(reversed_string)) # забыли указать что нужно приводить к листу
# Подробнее про reversed: https://www.geeksforgeeks.org/python-reversed-function/

# можно изменять индексы
new[1] = 9999999
print(new) # [3.1, 9999999, 123]

list1 = [0]
list2 = [1]
print(list1) # [0]
print(list2) # [1]