# Создание пустого списка
empty_list = []

# Второй способ
empty_list1 = list()

# Список это изменяемый тип, поэтому он изменяется без создания нового объекта. Дополнительная память не выделяется

# Добавление элемента, добавляется в конец
empty_list.append('123')
print(empty_list) # ['123']
empty_list.append('456')
print(empty_list) # ['123', '456']

# Расширение списка другим списком, добавляется в конец
empty_list.extend(['666', '777', '888']) # ['123', '456', '666', '777', '888']
print(empty_list)

# Подсчет длины списка
print(len(empty_list)) # 5

# Обращение к индексам списка
print(empty_list[0])
print(empty_list[1])
print(empty_list[-1]) # с конца

# Списки можно умножать
print(empty_list * 2) # ['123', '456', '666', '777', '888', '123', '456', '666', '777', '888']
# Здесь исходный список не меняется (важно). Изменяемые объекты меняются когда мы вызываем какие-то методы на них
print(empty_list) # ['123', '456', '666', '777', '888']
print()

# Диапазоны списка (слайсы)
print('Диапазоны списка')
print(empty_list[1:3]) # 1 - включительно, 3 - не включительно // ['456', '666']
print(empty_list[3:-1]) # ['777']
# В интервалах можно выходить за границы, он просто покажет все входящее в этот диапазон
print(empty_list[3:1000]) # 1000 индекса в массиве нет // ['777', '888']
# Помимо того, что можно задать нижнюю и верхнюю границы, через еще одно : можем задать шаг, который может быть любым
print(empty_list[0:5:2]) # ['123', '666', '888']
# Можно убрать верхнюю и/или нижнюю границы, это будет означать, что мы хотим начинать с самого начала / до самого конца
print(empty_list[::2]) # ['123', '666', '888']
# Можно задать отрицательный шаг
print(empty_list[::-1]) # берем весь диапазон и разворачиваем в обратном порядке // ['888', '777', '666', '456', '123']
print(empty_list[3:0:-1]) # с 3 по 0 в обратном порядке // ['777', '666', '456']

# Так как питон язык с динамической типизацией, мы не указываем из каких типов элементов состоит список
new = ['123456', 123, 3.1, '', None]
print(new) # ['123', 123, 3.1, '', None]
# Более того, элементом списка может быть еще один список
new.append(['111', 222, 444.44]) # ['123456', 123, 3.1, '', None, ['111', 222, 444.44]]
print(new)
# Удаление (вытягивание) элемента из списка по индексу
print(new.pop(0)) # '123456'
print(new) # [123, 3.1, '', None, ['111', 222, 444.44]]

print()

# Cортировка списков
print('Сортировка списков')
# new.sort() # сортирует список, меняя элементы местами, в данном случае в алфавитном порядке
# print(new) # TypeError: '<' not supported between instances of 'str' and 'float'
# дело в том что список состоит из разных типов и к сожалению строгая типизация не пытается приводить типы друг к другу
# когда мы хотим сравнить строчку с числом (нужно для сортировки) то питон говорит что мы не можем этго сделать
# пока просто уберем строчку, оставим только числа
new = [12, 123, 3.1]
new.sort()
print(new) # [3.1, 12, 123] // В порядке возрастания
new.sort(reverse=True)
print(new) # [123, 12, 3.1] // В порядке убывания
# Метод sort() новый список не создает, а сортирует исходный
# Eсли мы хотим вместе с сортировкой создать новый список, то у нас есть встроенная команда sorted(),
# куда мы можем передать список и его распечатать
print(sorted(new)) # Создается новый объект, оригинальный никак не пострадает // [3.1, 12, 123]
print(new) # [123, 12, 3.1]
# Как правило, если мы вызываем method(var), то будет создаваться новый объект
# Когда мы вызываем метод у конкретного объекта скрее всего он будет изменен
# boolean
print(bool([])) # False
print(bool([0])) # True

print()

# Разворот списка
print('Разворот списка')
new.reverse() # С изменением старого объекта
print(new) # [3.1, 12, 123]
reversed_string = reversed(new) # Создание нового объекта # [123, 12, 3.1]
print(list(reversed_string)) # забыли указать что нужно приводить к листу
# Подробнее про reversed: https://www.geeksforgeeks.org/python-reversed-function/

# Можно изменять индексы
new[1] = 9999999
print(new) # [3.1, 9999999, 123]

list1 = [0]
list2 = [1]
print(list1) # [0]
print(list2) # [1]